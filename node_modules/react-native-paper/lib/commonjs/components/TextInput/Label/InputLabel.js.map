{"version":3,"sources":["InputLabel.tsx"],"names":["InputLabel","props","parentState","labelBackground","labelProps","label","error","onLayoutAnimatedText","hasActiveOutline","activeColor","placeholderStyle","baseLabelTranslateX","baseLabelTranslateY","font","fontSize","fontWeight","placeholderOpacity","wiggleOffsetX","labelScale","topPosition","paddingOffset","placeholderColor","errorColor","labelTranslationX","transform","translateX","labeled","interpolate","inputRange","outputRange","labelStyle","value","translateY","scale","StyleSheet","absoluteFill","opacity","focused","labelLayout","measured","top","color"],"mappings":"6PAAA,oDACA,yCACA,mF,uGAIA,GAAMA,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACC,KAAD,CAA4B,IACrCC,CAAAA,WADqC,CACJD,KADI,CACrCC,WADqC,CACxBC,eADwB,CACJF,KADI,CACxBE,eADwB,uBAsBzCF,KAAK,CAACG,UAtBmC,CAI3CC,KAJ2C,mBAI3CA,KAJ2C,CAK3CC,KAL2C,mBAK3CA,KAL2C,CAM3CC,oBAN2C,mBAM3CA,oBAN2C,CAO3CC,gBAP2C,mBAO3CA,gBAP2C,CAQ3CC,WAR2C,mBAQ3CA,WAR2C,CAS3CC,gBAT2C,mBAS3CA,gBAT2C,CAU3CC,mBAV2C,mBAU3CA,mBAV2C,CAW3CC,mBAX2C,mBAW3CA,mBAX2C,CAY3CC,IAZ2C,mBAY3CA,IAZ2C,CAa3CC,QAb2C,mBAa3CA,QAb2C,CAc3CC,UAd2C,mBAc3CA,UAd2C,CAe3CC,kBAf2C,mBAe3CA,kBAf2C,CAgB3CC,aAhB2C,mBAgB3CA,aAhB2C,CAiB3CC,UAjB2C,mBAiB3CA,UAjB2C,CAkB3CC,WAlB2C,mBAkB3CA,WAlB2C,CAmB3CC,aAnB2C,mBAmB3CA,aAnB2C,CAoB3CC,gBApB2C,mBAoB3CA,gBApB2C,CAqB3CC,UArB2C,mBAqB3CA,UArB2C,CAwB7C,GAAMC,CAAAA,iBAAiB,CAAG,CACxBC,SAAS,CAAE,CACT,CAEEC,UAAU,CAAEvB,WAAW,CAACwB,OAAZ,CAAoBC,WAApB,CAAgC,CAC1CC,UAAU,CAAE,CAAC,CAAD,CAAI,CAAJ,CAD8B,CAE1CC,WAAW,CAAE,CAAClB,mBAAD,CAAsB,CAAtB,CAF6B,CAAhC,CAFd,CADS,CADa,CAA1B,CAYA,GAAMmB,CAAAA,UAAU,+BACXjB,IADW,EAEdC,QAAQ,CAARA,QAFc,CAGdC,UAAU,CAAVA,UAHc,CAIdS,SAAS,CAAE,CACT,CAEEC,UAAU,CAAEvB,WAAW,CAACI,KAAZ,CAAkBqB,WAAlB,CAA8B,CACxCC,UAAU,CAAE,CAAC,CAAD,CAAI,GAAJ,CAAS,CAAT,CAD4B,CAExCC,WAAW,CAAE,CAAC,CAAD,CAAI3B,WAAW,CAAC6B,KAAZ,EAAqBzB,KAArB,CAA6BW,aAA7B,CAA6C,CAAjD,CAAoD,CAApD,CAF2B,CAA9B,CAFd,CADS,CAQT,CAEEe,UAAU,CAAE9B,WAAW,CAACwB,OAAZ,CAAoBC,WAApB,CAAgC,CAC1CC,UAAU,CAAE,CAAC,CAAD,CAAI,CAAJ,CAD8B,CAE1CC,WAAW,CAAE,CAACjB,mBAAD,CAAsB,CAAtB,CAF6B,CAAhC,CAFd,CARS,CAeT,CAEEqB,KAAK,CAAE/B,WAAW,CAACwB,OAAZ,CAAoBC,WAApB,CAAgC,CACrCC,UAAU,CAAE,CAAC,CAAD,CAAI,CAAJ,CADyB,CAErCC,WAAW,CAAE,CAACX,UAAD,CAAa,CAAb,CAFwB,CAAhC,CAFT,CAfS,CAJG,EAAhB,CA6BA,MAAOb,CAAAA,KAAK,CAGV,6BAAC,qBAAD,CAAU,IAAV,EACE,aAAa,CAAC,MADhB,CAEE,KAAK,CAAE,CACL6B,wBAAWC,YADN,CAEL,CACEC,OAAO,CAELlC,WAAW,CAAC6B,KAAZ,EAAqB7B,WAAW,CAACmC,OAAjC,CACInC,WAAW,CAACoC,WAAZ,CAAwBC,QAAxB,CACE,CADF,CAEE,CAHN,CAII,CAPR,CAFK,CAWLhB,iBAXK,CAFT,iDAgBGpB,eAhBH,cAgBGA,eAAe,CAAG,CACjBD,WAAW,CAAXA,WADiB,CAEjB4B,UAAU,CAAVA,UAFiB,CAGjB1B,UAAU,CAAEH,KAAK,CAACG,UAHD,CAAH,CAhBlB,CAqBE,6BAAC,qBAAD,EACE,QAAQ,CAAEG,oBADZ,CAEE,KAAK,CAAE,CACLG,gBADK,CAEL,CACE8B,GAAG,CAAErB,WADP,CAFK,CAKLW,UALK,CAMLV,aAAa,EAAI,EANZ,CAOL,CACEqB,KAAK,CAAEhC,WADT,CAEE2B,OAAO,CAAElC,WAAW,CAACwB,OAAZ,CAAoBC,WAApB,CAAgC,CACvCC,UAAU,CAAE,CAAC,CAAD,CAAI,CAAJ,CAD2B,CAEvCC,WAAW,CAAE,CAACrB,gBAAgB,CAAG,CAAH,CAAO,CAAxB,CAA2B,CAA3B,CAF0B,CAAhC,CAFX,CAPK,CAFT,CAiBE,aAAa,CAAE,CAjBjB,iDAmBGH,KAnBH,CArBF,CA0CE,6BAAC,qBAAD,EACE,KAAK,CAAE,CACLK,gBADK,CAEL,CACE8B,GAAG,CAAErB,WADP,CAFK,CAKLW,UALK,CAMLV,aANK,CAOL,CACEqB,KAAK,CAAEnC,KAAK,EAAIgB,UAAT,CAAsBA,UAAtB,CAAmCD,gBAD5C,CAEEe,OAAO,CAAEpB,kBAFX,CAPK,CADT,CAaE,aAAa,CAAE,CAbjB,kDAeGX,KAfH,CA1CF,CAHU,CA+DR,IA/DJ,CAgED,CAjID,C,aAmIeL,U","sourcesContent":["import React from 'react';\nimport { Animated, StyleSheet } from 'react-native';\nimport AnimatedText from '../../Typography/AnimatedText';\n\nimport { InputLabelProps } from '../types';\n\nconst InputLabel = (props: InputLabelProps) => {\n  const { parentState, labelBackground } = props;\n\n  const {\n    label,\n    error,\n    onLayoutAnimatedText,\n    hasActiveOutline,\n    activeColor,\n    placeholderStyle,\n    baseLabelTranslateX,\n    baseLabelTranslateY,\n    font,\n    fontSize,\n    fontWeight,\n    placeholderOpacity,\n    wiggleOffsetX,\n    labelScale,\n    topPosition,\n    paddingOffset,\n    placeholderColor,\n    errorColor,\n  } = props.labelProps;\n\n  const labelTranslationX = {\n    transform: [\n      {\n        // Offset label scale since RN doesn't support transform origin\n        translateX: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [baseLabelTranslateX, 0],\n        }),\n      },\n    ],\n  };\n\n  const labelStyle = {\n    ...font,\n    fontSize,\n    fontWeight,\n    transform: [\n      {\n        // Wiggle the label when there's an error\n        translateX: parentState.error.interpolate({\n          inputRange: [0, 0.5, 1],\n          outputRange: [0, parentState.value && error ? wiggleOffsetX : 0, 0],\n        }),\n      },\n      {\n        // Move label to top\n        translateY: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [baseLabelTranslateY, 0],\n        }),\n      },\n      {\n        // Make label smaller\n        scale: parentState.labeled.interpolate({\n          inputRange: [0, 1],\n          outputRange: [labelScale, 1],\n        }),\n      },\n    ],\n  };\n\n  return label ? (\n    // Position colored placeholder and gray placeholder on top of each other and crossfade them\n    // This gives the effect of animating the color, but allows us to use native driver\n    <Animated.View\n      pointerEvents=\"none\"\n      style={[\n        StyleSheet.absoluteFill,\n        {\n          opacity:\n            // Hide the label in minimized state until we measure it's width\n            parentState.value || parentState.focused\n              ? parentState.labelLayout.measured\n                ? 1\n                : 0\n              : 1,\n        },\n        labelTranslationX,\n      ]}\n    >\n      {labelBackground?.({\n        parentState,\n        labelStyle,\n        labelProps: props.labelProps,\n      })}\n      <AnimatedText\n        onLayout={onLayoutAnimatedText}\n        style={[\n          placeholderStyle,\n          {\n            top: topPosition,\n          },\n          labelStyle,\n          paddingOffset || {},\n          {\n            color: activeColor,\n            opacity: parentState.labeled.interpolate({\n              inputRange: [0, 1],\n              outputRange: [hasActiveOutline ? 1 : 0, 0],\n            }),\n          },\n        ]}\n        numberOfLines={1}\n      >\n        {label}\n      </AnimatedText>\n      <AnimatedText\n        style={[\n          placeholderStyle,\n          {\n            top: topPosition,\n          },\n          labelStyle,\n          paddingOffset,\n          {\n            color: error && errorColor ? errorColor : placeholderColor,\n            opacity: placeholderOpacity,\n          },\n        ]}\n        numberOfLines={1}\n      >\n        {label}\n      </AnimatedText>\n    </Animated.View>\n  ) : null;\n};\n\nexport default InputLabel;\n"]}